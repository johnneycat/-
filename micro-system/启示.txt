这个例子给出了底层做封装的意义。
1、底层实现主要操作函数的标准封装：
	struct f_ops ops = {
				.read = sys_read,
				.write = sys_write,
				…
			}
这样，上层仅仅需要调用标准通用函数接口就可以了。
2、关于函数注册问题：
首先我承认这个地方花费了很久。最重要的是明白函数的提交是整个函数结构体，当然这个结构体可以被再次封装，最终以标准结构体的方式提交到最上层，最上层再进行解析和调用